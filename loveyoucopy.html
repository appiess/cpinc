< html >
    <头>
        < meta  http-equiv =" Content-Type " content =" text/html;charset=UTF-8 " >
        < title > LOVE109❤️纪实小屋</ title >
        < link  rel ="快捷方式图标" href =" https://i.loli.net/2019/02/13/5c62f60e194c3.png " type =" image/x-icon " />
        <元 名称=视口”内容=“宽度=设备宽度，初始比例=1.0 ” >
        < meta  name =" viewport " content =" width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0 " >
        <!--<meta itemprop="image" content="./images/fenxiang.png" />-->
        <风格>
            html {
                高度： 100 %；
            }
            身体{
                font-family :  "Helvetica Neue" ,  "Luxi Sans" ,  "DejaVu Sans" , Tahoma ,  "Hiragino Sans GB" ,  "Microsoft Yahei" , sans-serif;
                背景： # 79a8ae；
                颜色： # CFEBE4；
                字体大小： 18像素；
                行高： 2；
                字母间距： 1.2像素；
                边距： 0；
            }
            一个{
                颜色： # ebf7f4；
            }
            . 身体——准备好了{
                背景： -webkit-linear-gradient (top ,  rgb ( 203 ,  235 ,  219 ) 0 % ,  rgb ( 55 ,  148 ,  192 ) 120 % );
                背景： -moz-linear-gradient (top ,  rgb ( 203 ,  235 ,  219 ) 0 % ,  rgb ( 55 ,  148 ,  192 ) 120 % );
                背景： -o-线性梯度（顶， RGB（203 ， 235 ， 219）0 ％， RGB（55 ， 148 ， 192）120 ％）;
                背景： -ms-linear-gradient (top ,  rgb ( 203 ,  235 ,  219 ) 0 % ,  rgb ( 55 ,  148 ,  192 ) 120 % );
                背景： 线性梯度（顶， RGB（203 ， 235 ， 219）0 ％， RGB（55 ， 148 ， 192）120 ％）;
            }
            . 文字{
                位置：固定；
                底部： 100像素；
                文本对齐：居中；
                宽度： 100 %；
            }
            . 画布{
                边距： 0自动；
                显示：块；
            }
            img #标志{
                宽度： 128像素；
                背景大小：封面；
                边界半径： 200像素；
                box-shadow :  0 px  0 px  40 px  rgba ( 63 ,  81 ,  181 ,  0.72 );
                边框： 3 px实心# 00a0ff；
                不透明度： 1；
                边距： 0自动；
                边距顶部： 20像素；
                边距底部： 20像素；
                过渡：全部1.0秒；
            }
            #标志：悬停{
                box-shadow :  0  0  10 px  # fff ;
                -webkit-box-shadow :  0  0  19 px  # fff ;
                变换： 旋转（360度）；
                -ms-transform ： 旋转（360度）；/* IE 9 */
                -moz-transform ： 旋转（360度）；/* 火狐 */
                -webkit-transform ： 旋转（360度）；/* Safari 和 Chrome */
                -o-transform ： 旋转（360度）；/* 歌剧 */
                过滤器：程序：DXImageTransform.Microsoft.BasicImage(rotation=3);
            }
            . cs {
                宽度： 100 %；
                高度： 100 %；
                边距： 0自动；
                位置：绝对；
                文本对齐：居中；
            }
            . 文字{
                位置：固定；
                底部： 20像素；
                文本对齐：居中；
                宽度： 100 %；
                字体粗细：粗体；
            }
            . 文本右{
                位置：固定；
                底部： 50像素；
                文本对齐：右；
                宽度： 100 %；
                字体粗细：粗体；
            }
        </风格>
    
    </头>
    
    <身体>
    <!--头像-->
    < div  class =" cs " >
        < img  src =" https://love109.cn/images/love109.jpg " id ="标志" >
    </ div >
    < canvas  class =" canvas " width =" 1820 " height =" 905 " > </ canvas >
    < p  class =" text " style =" color: #ed3073; " >我们已经相爱了
    <跨度 ID = “ span_dt_dt ” > </跨度> < BR >请在电脑端浏览本页😘
    </ p >
    <脚本 语言=“ javascript ” >
        函数 show_date_time ( )  {
            窗口。setTimeout ( "show_date_time()" ,  1000 ) ;
            var  date1 =  '2019/01/01 00:00:00' ;   //开始时间
            var  date2  =  new  Date ( ) ;
            timeold  =  DATE2 。getTime ( )  - 新 日期( date1 ) 。获取时间（）；;
            sectimeold  =  timeold  /  1000
            秒数 = 数学。地板（sectimeold ）；
            msPerDay  =  24  *  60  *  60  *  1000
            e_daysold  =  timeold  /  msPerDay
            天数 = 数学。地板（e_daysold ）；
            e_hrsold  =  （e_daysold  -  daysold ） *  24 ;
            hrsold  = 数学。地板( e_hrsold ) ;
            e_minsold  =  ( e_hrsold  -  hrsold )  *  60 ;
            minsold  = 数学。地板（（e_hrsold  -  hrsold ） *  60 ）；
            秒 = 数学。地板（（e_minsold  -  minsold ） *  60 ）；
            span_dt_dt 。innerHTML  =  daysold  +  "天"  +  hrsold  +  "小时"  +  minsold  +  "分"  +  seconds  +  "秒" ;
        }
        show_date_time ( ) ;
    </脚本>
    <脚本>
        变量 S  =  {
            初始化：函数 （） {
                小号。绘图。init ( '.canvas' ) ;
                文件。身体。类列表。添加（'身体--准备好' ）;
                小号。用户界面。模拟（“莉丽❤️|我愿意陪你|校服到旅行|青丝到白发|沧海到桑田|学校到殿堂|天涯到海角|天荒到地老|到永远|#倒计时3|我爱你！❤️|#time" ) ;
                小号。绘图。循环（函数 （） {
                    小号。形状。渲染（）；
                } ) ;
            }
        } ;
        小号。绘图 =  (函数 ( )  {
            无功 画布，
                上下文，
                渲染Fn ，
                requestFrame  =  window 。requestAnimationFrame  ||
                    窗口。webkitRequestAnimationFrame  ||
                    窗口。mozRequestAnimationFrame  ||
                    窗口。oRequestAnimationFrame  ||
                    窗口。msRequestAnimationFrame  ||
                    函数 （回调） {
                        窗口。setTimeout (回调,  1000  /  60 ) ;
                    } ;
            返回 {
                初始化：函数 （el ） {
                    画布 = 文档。查询选择器（el ）；
                    上下文 = 画布。getContext ( '2d' ) ;
                    这个。调整画布（）；
                    窗口。addEventListener （'调整大小' ， 函数 （e ） {
                        小号。绘图。调整画布（）；
                    } ) ;
                } ,
                循环：函数 （fn ） {
                    渲染Fn  =  ! 渲染Fn？fn : renderFn ;
                    这个。清除帧（）；
                    渲染Fn ( ) ;
                    请求帧。调用（窗口， 这个。循环。绑定（这个））；
                } ,
                调整画布：函数 （） {
                    画布。宽度 = 窗口。内部宽度 -  100 ;
                    画布。高度 = 窗口。内部高度 -  30 ;
                } ,
                clearFrame :函数 ( )  {
                    上下文。clearRect （0 ， 0 ， 画布。宽度， 画布。高度）;
                } ,
                获取区域：函数 （） {
                    返回 { w：画布。宽度， h：画布。高度} ;
                } ,
                drawCircle：函数 （p ， c ） {
                    上下文。填充样式 =  c 。渲染（）；
                    上下文。开始路径（）；
                    上下文。弧（p 。X ， p 。ÿ ， p 。Ž ， 0 ， 2  * 数学。PI ， 真）;
                    上下文。关闭路径( ) ;
                    上下文。填充( ) ;
                }
            } ;
        } ( ) ) ;
        小号。用户界面 =  (函数 ( )  {
            var 间隔,
                当前动作,
                时间，
                maxShapeSize  =  30 ,
                序列 =  [ ] ,
                cmd  =  '#' ;
            函数 格式时间（日期） {
                var  h  = 日期。获取时间( ) ,
                    米 = 日期。获取分钟( ) ,
                    m  =  m  <  10 ? '0'  + 米：米；
                返回 h  +  ':'  +  m ;
            }
            函数 getValue （值） {
                返回 值 && 值。拆分（'' ）[ 1 ] ;
            }
            函数 getAction （值） {
                价值 = 价值 && 价值。拆分（'' ）[ 0 ] ;
                返回 值 && 值[ 0 ]  ===  cmd  && 值。子串( 1 ) ;
            }
            函数 timedAction ( fn ,  delay ,  max ,  reverse )  {
                clearInterval （间隔）；
                currentAction  = 反向？最大：1 ；
                fn ( currentAction ) ;
                if  ( ! max  ||  ( ! reverse  &&  currentAction  <  max )  ||  ( reverse  &&  currentAction  >  0 ) )  {
                    间隔 =  setInterval (函数 ( )  {
                        currentAction  = 反向？currentAction  -  1 : currentAction  +  1 ;
                        fn ( currentAction ) ;
                        if  ( ( ! reverse  &&  max  &&  currentAction  ===  max )  ||  ( reverse  &&  currentAction  ===  0 ) )  {
                            clearInterval （间隔）；
                        }
                    } , 延迟) ;
                }
            }
            函数 的performAction （值） {
                变量 动作，
                    价值，
                    当前；
                序列 =  typeof  (值)  ===  '对象' ? 值：序列。的concat （值。分裂（'|' ）） ;
                timedAction (函数 (索引)  {
                    当前 = 序列。移位( ) ;
                    动作 =  getAction （当前）；
                    值 = 的getValue （电流）;
                    开关 （动作） {
                        案例 “倒计时”：
                            值 =  parseInt (值)  ||  10 ;
                            值 = 值 >  0 ? 值：10 ；
                            timedAction (函数 (索引)  {
                                如果 （索引 ===  0 ） {
                                    如果 （序列。长度 ===  0 ） {
                                        小号。形状。switchShape （小号。ShapeBuilder 。字母（'' ）） ;
                                    } 其他 {
                                        执行动作（序列）；
                                    }
                                } 其他 {
                                    小号。形状。switchShape （小号。ShapeBuilder 。字母（索引）， 真）;
                                }
                            } ,  1000 , 价值, 真) ;
                            打破;
                        案例 “矩形”：
                            价值 = 价值 && 价值。拆分（'x' ）;
                            值 =  （值 && 值。长度 ===  2 ）？值：[ maxShapeSize ， maxShapeSize  /  2 ] ；
                            小号。形状。switchShape （小号。ShapeBuilder 。矩形（数学。分钟（maxShapeSize ， parseInt函数（值[ 0 ] ））， 数学式。分钟（maxShapeSize ， parseInt函数（值[ 1 ] ））））;
                            打破;
                        案例 “圆圈”：
                            值 =  parseInt (值)  ||  最大形状大小；
                            价值 = 数学。最小值（值， maxShapeSize ）；
                            小号。形状。switchShape （小号。ShapeBuilder 。圈（值））;
                            打破;
                        案例 “时间”：
                            var  t  =  formatTime （新 日期（））；
                            如果 （序列。长度 >  0 ） {
                                小号。形状。switchShape （小号。ShapeBuilder 。字母（吨））;
                            } 其他 {
                                计时动作(函数 ( )  {
                                    t  = 格式时间（新 日期（））；
                                    如果 ( t  !== 时间)  {
                                        时间 =  t ;
                                        小号。形状。switchShape （小号。ShapeBuilder 。字母（时间））;
                                    }
                                } ,  1000 ) ;
                            }
                            打破;
                        默认：
                            小号。形状。switchShape （小号。ShapeBuilder 。函（电流[ 0 ]  ===  CMD？'HacPai' ：电流））;
                    }
                } ,  2000 , 序列. 长度) ;
            }
            返回 {
                模拟：功能 （动作） {
                    performAction (动作) ;
                }
            } ;
        } ( ) ) ;
        小号。点 = 函数 （参数） {
            这个。x  = 参数。X ;
            这个。y  = 参数。Ÿ ;
            这个。z  = 参数。ž ;
            这个。a  = 参数。一个;
            这个。h  = 参数。^ h ;
        } ;
        小号。颜色 = 函数 ( r ,  g ,  b ,  a )  {
            这个。r  =  r ;
            这个。克 = 克；
            这个。乙 = 乙;
            这个。一个 = 一个；
        } ;
        小号。颜色。原型 =  {
            渲染：函数 （） {
                返回 'RGBA（'  + 此。[R  +  ''  +  +此。克 +  ''  + 此。b  +  ''  + 此。一个 +  '）' ;
            }
        } ;
        小号。点 = 函数 ( x ,  y )  {
            这个。p  = 新 小号。点( {
                x : x ,
                y : y ,
                z : 5 ,
                一：1 ，
                小时：0
            } ) ;
            这个。e  =  0.07 ;
            这个。s  = 真;
            这个。Ç  = 新 小号。色（255 ， 255 ， 255 ， 此。p 。一个）;
            这个。t  = 这个。克隆( ) ;
            这个。q  =  [ ] ;
        } ;
        小号。点。原型 =  {
            克隆：函数 （） {
                返回 新的 S 。点( {
                    x：这个。X ，
                    你：这个。ÿ ，
                    z：这个。ž ，
                    一：这个。一，
                    赫：这个。H
                } ) ;
            } ,
            _draw :函数 ( )  {
                这个。丙。一个 = 这个。p 。一个;
                小号。绘图。画圆（此。p ， 此。Ç ）;
            } ,
            _moveTowards：函数 （n ） {
                var 详细信息 =  this 。distanceTo ( n ,  true ) ,
                    dx  = 详细信息[ 0 ] ,
                    dy  = 详细信息[ 1 ] ,
                    d  = 详细信息[ 2 ] ,
                    e  = 这个。e  *  d ;
                如果 （此。p 。ħ  ===  - 1 ） {
                    这个。p 。x  =  n 。X ;
                    这个。p 。y  =  n 。Ÿ ;
                    返回 真；
                }
                如果 ( d  >  1 )  {
                    这个。p 。x  -=  ( ( dx  /  d )  *  e ) ;
                    这个。p 。y  -=  ( ( dy  /  d )  *  e ) ;
                } 其他 {
                    如果 （此。p 。ħ  >  0 ） {
                        这个。p 。^ h - ;
                    } 其他 {
                        返回 真；
                    }
                }
                返回 假；
            } ,
            _更新：函数 （） {
                如果 （此。_moveTowards （此。吨）） {
                    无功 p  = 这个。q 。移位( ) ;
                    如果 ( p )  {
                        这个。吨。x  =  p 。×  ||  这个。p 。X ;
                        这个。吨。y  =  p 。是 ||  这个。p 。Ÿ ;
                        这个。吨。z  =  p 。z  ||  这个。p 。ž ;
                        这个。吨。a  =  p 。一个 ||  这个。p 。一个;
                        这个。p 。h  =  p 。h  ||  0 ;
                    } 其他 {
                        如果 （此。小号） {
                            这个。p 。x  -= 数学。罪（数学。随机（） *  3.142 ）；
                            这个。p 。y  -= 数学。罪（数学。随机（） *  3.142 ）；
                        } 其他 {
                            这个。移动(新 S .点( {
                                x：这个。p 。x  +  (数学。随机( )  *  50 )  -  25 ,
                                你：这个。p 。y  +  (数学.随机( )  *  50 )  -  25
                            } ) ) ;
                        }
                    }
                }
                d  = 这个。p 。一个 - 这个。吨。一个;
                这个。p 。a  = 数学。最大（0.1 ， 此。p 。一个 -  （d  *  0.05 ））;
                d  = 这个。p 。z  - 这个。吨。ž ;
                这个。p 。z  = 数学。最大（1 ， 此。p 。ž  -  （d  *  0.05 ））;
            } ,
            距离：函数 （n ， 细节） {
                无功 dx  = 这个。p 。x  -  n 。X ，
                    dy  = 这个。p 。y  -  n 。ÿ ，
                    d  = 数学。sqrt （dx  *  dx  +  dy  *  dy ）；
                退货 详情？[ dx ,  dy ,  d ] : d ;
            } ,
            移动：函数 （p ， 避免静态） {
                if  ( ! avoidStatic  ||  ( avoidStatic  &&  this . distanceTo ( p )  >  1 ) )  {
                    这个。q 。推( p ) ;
                }
            } ,
            渲染：函数 （） {
                这个。_更新（）；
                这个。_画（）;
            }
        } ;
        小号。ShapeBuilder  =  (函数 ( )  {
            无功 间隙 =  13 ,
                shapeCanvas  = 文档。创建元素（'画布' ），
                shapeContext  =  shapeCanvas 。getContext ( '2d' ) ,
                字体大小 =  500 ,
                fontFamily  =  'Avenir, Helvetica Neue, Helvetica, Arial, sans-serif' ;
            函数 拟合( )  {
                形状画布。宽度 = 数学。地板（窗口。内部宽度 / 间隙） * 间隙；
                形状画布。高度 = 数学。地板（窗口。内部高度 / 间隙） * 间隙；
                形状上下文。填充样式 =  '红色' ;
                形状上下文。textBaseline  =  '中间' ;
                形状上下文。textAlign  =  '居中' ;
            }
            函数处理 画布( )  {
                var 像素 =  shapeContext 。getImageData （0 ， 0 ， shapeCanvas 。宽度， shapeCanvas 。高度）。数据；
                点 =  [ ] ,
                    像素,
                    x  =  0 ,
                    y  =  0 ,
                    fx  =  shapeCanvas 。宽度,
                    fy  =  shapeCanvas 。高度,
                    w  =  0 ,
                    h  =  0 ;
                for  ( var  p  =  0 ;  p  < 像素.长度;  p  +=  ( 4  *  gap ) )  {
                    如果 （像素[ p  +  3 ]  >  0 ） {
                        点。推（新的 小号。点（{
                            x : x ,
                            y : y
                        } ) ) ;
                        w  =  x  >  w ? x : w ;
                        h  =  y  >  h ? y : h ;
                        fx  =  x  <  fx ? x :外汇;
                        fy  =  y  <  fy ? y : fy ;
                    }
                    x  += 间隙；
                    if  ( x  >=  shapeCanvas .宽度)  {
                        x  =  0 ;
                        y  += 间隙；
                        p  += 间隙 *  4  *  shapeCanvas 。宽度；
                    }
                }
                返回 {点：点， w：w  +  fx ， h：h  +  fy } ；
            }
            函数 setFontSize ( s )  {
                形状上下文。字体 =  '粗体'  +  s  +  'px'  +  fontFamily ;
            }
            函数 isNumber ( n )  {
                回来 ！isNaN ( parseFloat ( n ) )  &&  isFinite ( n ) ;
            }
            函数 初始化（） {
                适合( ) ;
                窗口。addEventListener ( 'resize' ,  fit ) ;
            }
            // 在里面
            初始化（）；
            返回 {
                图像文件：函数 （网址， 回调） {
                    var  image  =  new  Image ( ) ,
                        一个 = 小号。绘图。getArea ( ) ;
                    图像。加载 = 函数 ( )  {
                        形状上下文。clearRect （0 ， 0 ， shapeCanvas 。宽度， shapeCanvas 。高度）;
                        形状上下文。的drawImage （此， 0 ， 0 ， 一个。ħ  *  0.6 ， 一个。ħ  *  0.6 ）;
                        回调（进程画布（））；
                    } ;
                    图像。onerror  = 函数 ( )  {
                        回调（小号。ShapeBuilder 。信（'什么？' ））;
                    } ;
                    图像。源代码 = 网址；
                } ,
                圆：函数 （d ） {
                    无功 r  = 数学。最大值( 0 ,  d )  /  2 ;
                    形状上下文。clearRect （0 ， 0 ， shapeCanvas 。宽度， shapeCanvas 。高度）;
                    形状上下文。开始路径（）；
                    形状上下文。弧（[R  * 间隙， - [R  * 间隙， - [R  * 间隙， 0 ， 2  * 数学。PI ， 假）;
                    形状上下文。填充( ) ;
                    形状上下文。关闭路径( ) ;
                    返回 进程画布( ) ;
                } ,
                字母:函数 ( l )  {
                    无功 s  =  0 ;
                    setFontSize ( fontSize ) ;
                    s  = 数学。分钟（字体大小，
                        （shapeCanvas 。宽度 /  shapeContext 。measureText （升）。宽） *  0.8  *  fontSize的，
                        （shapeCanvas 。高度 /  fontSize的） *  （ISNUMBER （升）？1：0.45 ） *  fontSize的）;
                    setFontSize ( s ) ;
                    形状上下文。clearRect （0 ， 0 ， shapeCanvas 。宽度， shapeCanvas 。高度）;
                    形状上下文。fillText方法（升， shapeCanvas 。宽度 /  2 ， shapeCanvas 。高度 /  2 ）;
                    返回 进程画布( ) ;
                } ,
                矩形：函数 （w ， h ） {
                    var  dots  =  [ ] ,
                        宽度 = 间隙 *  w ,
                        高度 = 间隙 *  h ；
                    for  ( var  y  =  0 ;  y  < 高度;  y  += 间隙)  {
                        for  ( var  x  =  0 ;  x  < 宽度;  x  += 间隙)  {
                            点。推（新的 小号。点（{
                                x : x ,
                                y : y
                            } ) ) ;
                        }
                    }
                    返回 {点：点， w：宽度， h：高度} ；
                }
            } ;
        } ( ) ) ;
        小号。形状 =  (函数 ( )  {
            var  dots  =  [ ] ,
                宽度 =  0 ,
                高度 =  0 ,
                CX  =  0 ,
                cy  =  0 ;
            函数 补偿( )  {
                变量 a  =  S 。绘图。getArea ( ) ;
                cx  =  a 。w  /  2  - 宽度 /  2 ;
                cy  =  a 。h  /  2  - 高度 /  2 ;
            }
            返回 {
                shuffleIdle：函数 （） {
                    变量 a  =  S 。绘图。getArea ( ) ;
                    为 （VAR  d  =  0 ;  d  < 点。长度;  d ++ ） {
                        如果 （！点[ d ] . s ） {
                            点[ d ] 。移动（{
                                x：数学。随机( )  *  a . W¯¯ ，
                                y：数学。随机( )  *  a . H
                            } ) ;
                        }
                    }
                } ,
                开关形状：函数 （n ， 快速） {
                    变量 大小，
                        一个 = 小号。绘图。getArea ( ) ;
                    宽度 =  n 。w ^ ;
                    高度 =  n 。^ h ;
                    补偿( ) ;
                    如果 （n 。点。长度 > 点。长度） {
                        大小 =  n 。点。长度 - 点。长度；
                        for  ( var  d  =  1 ;  d  <= 大小;  d ++ )  {
                            点。推（新 小号。点（一个。瓦特 /  2 ， 一个。ħ  /  2 ））;
                        }
                    }
                    无功 d  =  0 ,
                        我 =  0 ;
                    而 （n 。点。长度 >  0 ） {
                        我 = 数学。地板（数学。随机（） *  Ñ 。点。长度）;
                        点[ d ] 。e  = 快？0.25：（点[ d ] 。小号？0.14：0.11 ）;
                        如果 （点[ d ] 。小号） {
                            点[ d ] 。移动(新 S .点( {
                                z：数学。随机( )  *  20  +  10 ,
                                一：数学。随机( ) ,
                                小时: 18
                            } ) ) ;
                        } 其他 {
                            点[ d ] 。移动(新 S .点( {
                                z：数学。随机( )  *  5  +  5 ,
                                赫：快？18 : 30
                            } ) ) ;
                        }
                        点[ d ] 。s  = 真;
                        点[ d ] 。移动(新 S .点( {
                            x : n 。点[ i ] 。x  +  cx ,
                            y：n 。点[ i ] 。y  +  cy ,
                            一：1 ，
                            z : 5 ,
                            小时：0
                        } ) ) ;
                        名词。点 =  n 。点。切片( 0 ,  i ) 。的concat （Ñ 。点。切片（我 +  1 ））;
                        d ++ ;
                    }
                    为 （VAR 我 =  d ; 我 < 点。长度; 我++ ） {
                        如果 (点[ i ] . s )  {
                            点[ i ] 。移动(新 S .点( {
                                z：数学。随机( )  *  20  +  10 ,
                                一：数学。随机( ) ,
                                小时: 20
                            } ) ) ;
                            点[ i ] 。s  = 假；
                            点[ i ] 。e  =  0.04 ;
                            点[ i ] 。移动(新 S .点( {
                                x：数学。随机( )  *  a . W¯¯ ，
                                y：数学。随机( )  *  a . ^ h ，
                                a : 0.3 ,  //.4
                                z：数学。随机( )  *  4 ,
                                小时：0
                            } ) ) ;
                        }
                    }
                } ,
                渲染：函数 （） {
                    为 （VAR  d  =  0 ;  d  < 点。长度;  d ++ ） {
                        点[ d ] 。渲染（）；
                    }
                }
            } ;
        } ( ) ) ;
        小号。初始化（）；
    </脚本>
    <音频 自动播放=“自动播放”循环=“循环” >
        < source  src =" http://www.ytmp3.cn/down/57693.mp3 " type =" audio/mpeg " >
    </音频>
</正文>
</ html >
